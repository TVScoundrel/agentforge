/**
 * Shared Deduplication Utilities
 *
 * This module provides shared utilities for tool call deduplication across patterns.
 *
 * @module patterns/shared/deduplication
 */

import { createLogger, type LogLevel } from '@agentforge/core';

/**
 * Recursively normalize an object by sorting all keys at all levels
 * This ensures consistent serialization regardless of key order
 *
 * @param obj - Object to normalize
 * @returns Normalized object with sorted keys at all levels
 */
function normalizeObject(obj: any): any {
  if (obj === null || obj === undefined) {
    return obj;
  }

  // Handle arrays - normalize each element
  if (Array.isArray(obj)) {
    return obj.map(normalizeObject);
  }

  // Handle objects - sort keys and normalize values recursively
  if (typeof obj === 'object' && obj.constructor === Object) {
    const normalized: any = {};
    const sortedKeys = Object.keys(obj).sort();
    for (const key of sortedKeys) {
      normalized[key] = normalizeObject(obj[key]);
    }
    return normalized;
  }

  // Primitive values - return as-is
  return obj;
}

/**
 * Generate a cache key for a tool call based on tool name and arguments
 *
 * The cache key is generated by:
 * 1. Recursively sorting all object keys (including nested objects) alphabetically
 * 2. JSON stringifying the normalized arguments
 * 3. Combining tool name and stringified arguments with a colon separator
 *
 * This ensures that tool calls with the same arguments in different order
 * produce the same cache key, even for deeply nested objects.
 *
 * @param toolName - Name of the tool
 * @param args - Tool arguments (will be normalized for consistent hashing)
 * @returns Cache key string in format "toolName:normalizedArgs"
 *
 * @example
 * ```typescript
 * const key1 = generateToolCallCacheKey('search', { query: 'test', limit: 10 });
 * const key2 = generateToolCallCacheKey('search', { limit: 10, query: 'test' });
 * // key1 === key2 (argument order doesn't matter)
 *
 * const key3 = generateToolCallCacheKey('search', {
 *   filters: { type: 'article', status: 'published' }
 * });
 * const key4 = generateToolCallCacheKey('search', {
 *   filters: { status: 'published', type: 'article' }
 * });
 * // key3 === key4 (nested object order doesn't matter)
 * ```
 */
export function generateToolCallCacheKey(toolName: string, args: any): string {
  // Normalize the arguments recursively to ensure consistent key ordering
  const normalizedArgs = normalizeObject(args);
  const sortedArgs = JSON.stringify(normalizedArgs);
  return `${toolName}:${sortedArgs}`;
}

/**
 * Create a logger for a pattern with consistent configuration
 *
 * @param name - Logger name (e.g., 'agentforge:react')
 * @param defaultLevel - Default log level if LOG_LEVEL env var is not set
 * @returns Configured logger instance
 *
 * @example
 * ```typescript
 * const logger = createPatternLogger('agentforge:react');
 * logger.info('Action node complete', { iteration: 1 });
 * ```
 */
export function createPatternLogger(name: string, defaultLevel: LogLevel = 'info' as LogLevel) {
  const logLevel = (process.env.LOG_LEVEL?.toLowerCase() as LogLevel) || defaultLevel;
  return createLogger(name, { level: logLevel });
}

/**
 * Deduplication metrics for tracking performance
 */
export interface DeduplicationMetrics {
  /** Number of tools executed (not from cache) */
  toolsExecuted: number;
  /** Number of duplicate calls skipped (from cache) */
  duplicatesSkipped: number;
  /** Total number of observations/results */
  totalObservations: number;
  /** Percentage of calls that were deduplicated */
  deduplicationSavings: string;
}

/**
 * Calculate deduplication savings percentage
 *
 * @param duplicatesSkipped - Number of duplicate calls prevented
 * @param toolsExecuted - Number of tools actually executed
 * @returns Percentage string (e.g., "75%") or "0%" if no duplicates
 *
 * @example
 * ```typescript
 * const savings = calculateDeduplicationSavings(3, 1);
 * // savings === "75%" (3 out of 4 total calls were duplicates)
 * ```
 */
export function calculateDeduplicationSavings(
  duplicatesSkipped: number,
  toolsExecuted: number
): string {
  if (duplicatesSkipped === 0) {
    return '0%';
  }
  const total = toolsExecuted + duplicatesSkipped;
  return `${Math.round((duplicatesSkipped / total) * 100)}%`;
}

/**
 * Build deduplication metrics object
 *
 * @param toolsExecuted - Number of tools executed
 * @param duplicatesSkipped - Number of duplicates skipped
 * @param totalObservations - Total observations count
 * @returns Metrics object with calculated savings
 *
 * @example
 * ```typescript
 * const metrics = buildDeduplicationMetrics(1, 3, 4);
 * // metrics.deduplicationSavings === "75%"
 * ```
 */
export function buildDeduplicationMetrics(
  toolsExecuted: number,
  duplicatesSkipped: number,
  totalObservations: number
): DeduplicationMetrics {
  return {
    toolsExecuted,
    duplicatesSkipped,
    totalObservations,
    deduplicationSavings: calculateDeduplicationSavings(duplicatesSkipped, toolsExecuted),
  };
}

