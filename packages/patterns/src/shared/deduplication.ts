/**
 * Shared Deduplication Utilities
 *
 * This module provides shared utilities for tool call deduplication across patterns.
 *
 * @module patterns/shared/deduplication
 */

import { createLogger, type LogLevel } from '@agentforge/core';

/**
 * Generate a cache key for a tool call based on tool name and arguments
 *
 * The cache key is generated by:
 * 1. Sorting the argument object keys alphabetically for consistency
 * 2. JSON stringifying the sorted arguments
 * 3. Combining tool name and stringified arguments with a colon separator
 *
 * This ensures that tool calls with the same arguments in different order
 * produce the same cache key.
 *
 * @param toolName - Name of the tool
 * @param args - Tool arguments (will be sorted for consistent hashing)
 * @returns Cache key string in format "toolName:sortedArgs"
 *
 * @example
 * ```typescript
 * const key1 = generateToolCallCacheKey('search', { query: 'test', limit: 10 });
 * const key2 = generateToolCallCacheKey('search', { limit: 10, query: 'test' });
 * // key1 === key2 (argument order doesn't matter)
 * ```
 */
export function generateToolCallCacheKey(toolName: string, args: any): string {
  // Sort object keys for consistent hashing
  const sortedArgs = JSON.stringify(args, Object.keys(args || {}).sort());
  return `${toolName}:${sortedArgs}`;
}

/**
 * Create a logger for a pattern with consistent configuration
 *
 * @param name - Logger name (e.g., 'agentforge:react')
 * @param defaultLevel - Default log level if LOG_LEVEL env var is not set
 * @returns Configured logger instance
 *
 * @example
 * ```typescript
 * const logger = createPatternLogger('agentforge:react');
 * logger.info('Action node complete', { iteration: 1 });
 * ```
 */
export function createPatternLogger(name: string, defaultLevel: LogLevel = 'info' as LogLevel) {
  const logLevel = (process.env.LOG_LEVEL?.toLowerCase() as LogLevel) || defaultLevel;
  return createLogger(name, { level: logLevel });
}

/**
 * Deduplication metrics for tracking performance
 */
export interface DeduplicationMetrics {
  /** Number of tools executed (not from cache) */
  toolsExecuted: number;
  /** Number of duplicate calls skipped (from cache) */
  duplicatesSkipped: number;
  /** Total number of observations/results */
  totalObservations: number;
  /** Percentage of calls that were deduplicated */
  deduplicationSavings: string;
}

/**
 * Calculate deduplication savings percentage
 *
 * @param duplicatesSkipped - Number of duplicate calls prevented
 * @param toolsExecuted - Number of tools actually executed
 * @returns Percentage string (e.g., "75%") or "0%" if no duplicates
 *
 * @example
 * ```typescript
 * const savings = calculateDeduplicationSavings(3, 1);
 * // savings === "75%" (3 out of 4 total calls were duplicates)
 * ```
 */
export function calculateDeduplicationSavings(
  duplicatesSkipped: number,
  toolsExecuted: number
): string {
  if (duplicatesSkipped === 0) {
    return '0%';
  }
  const total = toolsExecuted + duplicatesSkipped;
  return `${Math.round((duplicatesSkipped / total) * 100)}%`;
}

/**
 * Build deduplication metrics object
 *
 * @param toolsExecuted - Number of tools executed
 * @param duplicatesSkipped - Number of duplicates skipped
 * @param totalObservations - Total observations count
 * @returns Metrics object with calculated savings
 *
 * @example
 * ```typescript
 * const metrics = buildDeduplicationMetrics(1, 3, 4);
 * // metrics.deduplicationSavings === "75%"
 * ```
 */
export function buildDeduplicationMetrics(
  toolsExecuted: number,
  duplicatesSkipped: number,
  totalObservations: number
): DeduplicationMetrics {
  return {
    toolsExecuted,
    duplicatesSkipped,
    totalObservations,
    deduplicationSavings: calculateDeduplicationSavings(duplicatesSkipped, toolsExecuted),
  };
}

